<?xml version="1.0" encoding="UTF-8"?>
<answers>
<answer questionid="1" value="3">
<explanation><p>Error is thrown but not recognised line(22) because the only catch attempts to catch an Exception and Exception is not a superclass of Error. Therefore only the code in the finally statement can be run before exiting with a runtime error (Exception in thread "main" java.lang.Error). </p>
</explanation>
</answer>
<answer questionid="2" value="3">
<explanation><p>(c) and (d) are correct.</p>
<p>(a) and (b) are incorrect because by contract hashCode() and equals() can't be overridden unless both are overridden.</p>
</explanation>
</answer>
<answer questionid="3" value="2">
<explanation><p>Java only ever passes arguments to a method by value (i.e. a copy of the variable) and never by reference. Therefore the value of the variable i remains unchanged in the main method.</p>
</explanation>
</answer>
<answer questionid="4" value="4">
<explanation><p>It gives different output while executing the same compiled code at different times.</p>
</explanation>
</answer>
<answer questionid="5" value="2">
<explanation><p>By the time line 8 has run, the only object without a reference is the one generated as a result of line 6. Remember that "Java is pass by value," so the reference variable x is not affected by the m1() method.</p>
<p>Ref: http://www.javaworld.com/javaworld/javaqa/2000-05/03-qa-0526-pass.html
</p>
</explanation>
</answer>
<answer questionid="6" value="1">
<explanation><p>(a), (b), and (d) are correct. The max() method is overloaded to take two arguments of type int, long, float, or double.</p>
<p>(c) is incorrect because the max() method only takes two arguments.</p>
</explanation>
</answer>
<answer questionid="7" value="1">
<explanation><p>Option 1 is correct because the notifyAll() method (along with wait() and notify()) must always be called from within a synchronized context.</p>
<p>Option 2 is incorrect because to call wait(), the thread must own the lock on the object that wait() is being invoked on, not the other way around.</p>
<p>Option 3 is wrong because notify() is defined in java.lang.Object.</p>
<p>Option 4 is wrong because notify() will not cause a thread to release its locks. The thread can only release its locks by exiting the synchronized code.</p>
</explanation>
</answer>
<answer questionid="8" value="3">
<explanation><p>The class correctly implements the Runnable interface with a legal public void run() method.</p>
<p>Option 1 is incorrect because interfaces are not extended; they are implemented.</p>
<p>Option 2 is incorrect because even though the class would compile and it has a valid public void run() method, it does not implement the Runnable interface, so the compiler would complain when creating a Thread with an instance of it.</p>
<p>Option 3 is incorrect because the run() method must be public.</p>
</explanation>
</answer>
<answer questionid="9" value="3">
<explanation><p>Both threads are operating on the same instance variables. Because the code is synchronized the first thread will complete before the second thread begins. Modify line 17 to print the thread names: System.out.println(Thread.currentThread().getName() + " x = " + x + ", y = " + y);</p>
</explanation>
</answer>
<answer questionid="10" value="3">
<explanation><p>(a) is wrong. 3/2 = 1 (integer arithmetic).</p>
<p>(b) is wrong. 3 &lt; 2 = false.</p>
<p>(c) is correct. 3 * 4 = 12.</p>
<p>(d) is correct. 3 &lt;&lt;2= 12. In binary 3 is 11, now shift the bits two places to the left and we get 1100 which is 12 in binary (3*2*2). </p>
</explanation>
</answer>
<answer questionid="11" value="2">
<explanation><p>Option 2 is correct. If an object can be accessed from a live thread, it can't be garbage collected.</p>
<p>Option 1 is wrong. Runtime.gc() asks the garbage collector to run, but the garbage collector never makes any guarantees about when it will run or what unreachable objects it will free from memory. </p>
<p>Option 3 is wrong. The garbage collector runs immediately the system is out of memory before an OutOfMemoryException is thrown by the JVM.</p>
<p>Option 4 is wrong. If this were the case then the garbage collector would actively hang onto objects until a program finishes - this goes against the purpose of the garbage collector.</p>
</explanation>
</answer>
<answer questionid="12" value="3">
<explanation><p>Look closely at line 2, is this an equality check (==) or an assignment (=). The condition at line 2 evaluates to false and also assigns false to bool. bool is now false so the condition at line 6 is not true. The condition at line 10 checks to see if bool is not true ( if !(bool == true) ), it isn't so line 12 is executed.</p>
</explanation>
</answer>
<answer questionid="13" value="3">
<explanation><p>Case expressions must be constant expressions. Since x is marked final, lines 12 and 13 are legal; however y is not a final so the compiler will fail at line 11.</p>
</explanation>
</answer>
<answer questionid="14" value="2">
<explanation><p>2 is correct because multiple threads are allowed to enter nonsynchronized code, even within a class that has some synchronized methods.</p>
<p>1 is incorrect because static methods can be synchronized; they synchronize on the lock on the instance of class java.lang.Class that represents the class type. </p>
<p>3 is incorrect because only methods not variables can be marked synchronized. </p>
<p>4 is incorrect because a sleeping thread still maintains its locks.</p>
</explanation>
</answer>
<answer questionid="15" value="3">
<explanation><p>Access modifiers dictate which classes, not which instances, may access features. </p>
<p>Methods and variables are collectively known as members. Method and variable members are given access control in exactly the same way. </p>
<p>private makes a member accessible only from within its own class </p>
<p>protected makes a member accessible only to classes in the same package or subclass of the class </p>
<p>default access is very similar to protected (make sure you spot the difference) default access makes a member accessible only to classes in the same package.</p>
<p>public means that all other classes regardless of the package that they belong to, can access the member (assuming the class itself is visible) </p>
<p>final makes it impossible to extend a class, when applied to a method it prevents a method from being overridden in a subclass, when applied to a variable it makes it impossible to reinitialise a variable once it has been initialised</p>
<p>abstract declares a method that has not been implemented.</p>
<p>transient indicates that a variable is not part of the persistent state of an object.</p>
<p>volatile indicates that a thread must reconcile its working copy of the field with the master copy every time it accesses the variable.</p>
<p>After examining the above it should be obvious that the access modifier that provides the most restrictions for methods to be accessed from the subclasses of the class from another package is C - protected. A is also a contender but C is more restrictive, B would be the answer if the constraint was the "same package" instead of "any package" in other words the subclasses clause in the question eliminates default.</p>
</explanation>
</answer>
<answer questionid="16" value="4">
<explanation><p>Option 4 is correct. Garbage collection takes place after the method has returned its reference to the object. The method returns to line 6, there is no reference to store the return value. so garbage collection takes place after line 6. </p>
<p>Option 1 is wrong. Because the reference to obj1 is stored in obj2[0]. The Object obj1 still exists on the heap and can be accessed by an active thread through the reference stored in obj2[0]. </p>
<p>Option 2 is wrong. Because it is only one of the references to the object obj1, the other reference is maintained in obj2[0]. </p>
<p>Option 3 is wrong. The garbage collector will not be called here because a reference to the object is being maintained and returned in obj2[0]. </p>
</explanation>
</answer>
<answer questionid="17" value="4">
<explanation><p>This question is not testing your knowledge of the continue statement. It is testing your knowledge of the order of evaluation of operands. Basically the prefix and postfix unary operators have a higher order of evaluation than the relational operators. So on line 4 the variable i is incremented and the variable j is decremented before the greater than comparison is made. As the loop executes the comparison on line 4 will be:
<br/>
if(i > j)
<br/>
if(2 > 9)
<br/>
if(3 > 8)
<br/>
if(4 > 7)
<br/>
if(5 > 6) at this point i is not less than 5, therefore the loop terminates and line 9 outputs the values of i and j as 5 and 6 respectively.
</p>
<p>The continue statement never gets to execute because i never reaches a value that is greater than j. </p>
</explanation>
</answer>
<answer questionid="18" value="2">
<explanation><p>Line 14 fails because == compares reference values, not object values. Line 16 succeeds because both String and primitive wrapper constructors resolve to the same value (except for the Character wrapper). Lines 18, 20, and 22 fail because the equals() method fails if the object classes being compared are different and not in the same tree hierarchy.</p>
</explanation>
</answer>
<answer questionid="19" value="1">
<explanation><p>The program flows as follows: I will be incremented after the while loop is entered, then I will be incremented (by zero) when the for loop is entered. The if statement evaluates to false, and the continue statement is never reached. The break statement tells the JVM to break out of the outer loop, at which point I is printed and the fragment is done.</p>
</explanation>
</answer>
<answer questionid="20" value="4">
<explanation><p>Compilation failed because static was an illegal start of expression - method variables do not have a modifier (they are always considered local).</p>
</explanation>
</answer>
<answer questionid="21" value="4">
<explanation><p>Any method (in this case, the main() method) that throws a checked exception (in this case, out.close() ) must be called within a try clause, or the method must declare that it throws the exception. Either main() must declare that it throws an exception, or the call to out.close() in the finally block must fall inside a (in this case nested) try-catch block.</p>
</explanation>
</answer>
<answer questionid="22" value="2">
<explanation><p>The first two iterations of the for loop both x and y are incremented. On the third iteration x is incremented, and for the first time becomes greater than 2. The short circuit or operator || keeps y from ever being incremented again and x is incremented twice on each of the last three iterations.</p>
</explanation>
</answer>
<answer questionid="23" value="4">
<explanation><p>Statement (d) describes an example of the equals() method behaving transitively. By the way, x, y,and z will all be the same type of wrapper. Statement (e) is true because x and y are referring to the same String object.</p>
<p>Statement (a) is incorrect the fragment will compile. Statement (b) is incorrect because x == y means that the two reference variables are referring to the same object. Statement (c) will only be true if x and y refer to the same String. It is possible for x and y to refer to two different String objects with the same value.</p>
</explanation>
</answer>
<answer questionid="24" value="3">
<explanation><p>Option 2 will not compile; the synchronized modifier applies only to methods.
</p><p>Option 1 and 2 will compile because protected and transient are legal variable modifiers. Option 4 will compile because volatile is a proper variable modifier.</p>
</explanation>
</answer>
<answer questionid="25" value="3">
<explanation><p>The iteration order of a Collection is the order in which an iterator moves through the elements of the Collection. The iteration order of a LinkedHashMap is determined by the order in which elements are inserted.</p> 
<p>When a new LinkedHashMap is created by passing a reference to an existing Collection to the constructor of a LinkedHashMap the Collection.addAll method will ultimately be invoked. </p>
<p>The addAll method uses an iterator to the existing Collection to iterate through the elements of the existing Collection and add each to the instance of the new LinkedHashMap. </p>
<p>Since the iteration order of the LinkedHashMap is determined by the order of insertion, the iteration order of the new LinkedHashMap must be the same as the interation order of the old Collection. 
</p>
</explanation>
</answer>
<answer questionid="26" value="4">
<explanation>
<p>(b) and (d). When a thread's run() method completes, the thread will die. The run() method must be declared public void and not take any arguments.</p>
<p>(a) is incorrect because classes can never extend interfaces. (c) is incorrect because the run() method is typically not empty; if it were, the thread would do nothing. (d) is incorrect because the mandatory method is run(). (e) is incorrect because the class implements Runnable.</p>
</explanation>
</answer>
<answer questionid="27" value="2">
<explanation><p>(a), (c), and (f) are correct. char c1 = 064770; is an octal representation of the integer value 27128, which is legal because it fits into an unsigned 16-bit integer. char c3 = 0xbeef; is a hexadecimal representation of the integer value 48879, which fits into an unsigned 16-bit integer. char c6 = '\uface'; is a Unicode representation of a character. </p>
<p>char c2 = 'face'; is wrong because you can't put more than one character in a char literal. The only other acceptable char literal that can go between single quotes is a Unicode value, and Unicode literals must always start with a '\u'.</p>
<p>char c4 = \u0022; is wrong because the single quotes are missing.</p>
<p>char c5 = '\iface'; is wrong because it appears to be a Unicode representation (notice the backslash), but starts with '\i' rather than '\u'. </p>
</explanation>
</answer>
<answer questionid="28" value="1">
<explanation><p>Option 1 is correct. It uses correct array declaration and correct array construction.</p>
<p>Option 2 is incorrect. It generates a compiler error: incompatible types because the array variable declaration is not correct. The array construction expects a reference type, but it is supplied with a primitive type in the declaration.</p>
<p>Option 3 is incorrect. It generates a compiler error: incompatible types because a string literal is not assignable to a character type variable. </p>
<p>Option 4 is wrong, it generates a compiler error &lt;identifier&gt; expected. The compiler thinks that you are trying to create two arrays because there are two array initialisers to the right of the equals, whereas your intention was to create a 3 x 3 two-dimensional array.</p>
</explanation>
</answer>
<answer questionid="29" value="3">
<explanation><p>Option 3 is correct because first the Foo instance is created, which means the Foo constructor runs and prints "foo". Next, the makeBar() method is invoked which creates a Bar, which means the Bar constructor runs and prints "bar", and finally the go() method is invoked on the new Bar instance, which means the go() method prints "hi".</p>
</explanation>
</answer>
<answer questionid="30" value="1">
<explanation><p>Option 1 is correct. wait() causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.</p>
<p>Option 2 is wrong. notify() - wakes up a single thread that is waiting on this object's monitor. </p>
<p>Option 3 is wrong. notifyAll() - wakes up all threads that are waiting on this object's monitor.</p>
<p>Option 4 is wrong. Typically, releasing a lock means the thread holding the lock (in other words, the thread currently in the synchronized method) exits the synchronized method. At that point, the lock is free until some other thread enters a synchronized method on that object. Does entering/exiting synchronized code mean that the thread execution stops? Not necessarily because the thread can still run code that is not synchronized. I think the word directly in the question gives us a clue. Exiting synchronized code does not directly stop the execution of a thread.</p>
</explanation>
</answer>
<answer questionid="31" value="4">
<explanation>
<p>First, list of strings is sorted in ascending order, result is A, B, C, D. Then applying the filter, value B is excluded from the list and final result is the concatenation of each element from the list. </p>
</explanation>
</answer>
<answer questionid="32" value="4">
<explanation>
<p>Compilation fails because you cannot reference from static context a non-static variable. The inner class should be static. Furthermore, you cannot inherit default method from types I1 &amp; I2.</p>
</explanation>
</answer>
<answer questionid="33" value="1">
<explanation/>
</answer>
<answer questionid="34" value="1">
<explanation/>
</answer>
<answer questionid="35" value="2">
<explanation/>
</answer>
<answer questionid="36" value="3">
<explanation/>
</answer>
<answer questionid="37" value="4">
<explanation/>
</answer>
<answer questionid="38" value="2">
<explanation/>
</answer>
<answer questionid="39" value="4">
<explanation/>
</answer>
<answer questionid="40" value="2">
<explanation/>
</answer>
</answers>
